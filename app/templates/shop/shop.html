<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Character encoding for proper text display -->
    <meta charset="UTF-8">
    <!-- Responsive viewport for mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Page title that appears in browser tab -->
    <title>Shop - ATBI Agri-Aqua Products</title>
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='images/agrilogo.png') }}">
    <!-- Link to external CSS file for styling -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/shop.css') }}">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
</head>
</head>
<body>
    <!-- Header Section - Fixed navigation bar at the top -->
    <header class="header">
        <!-- Container to center and limit the width of header content -->
        <div class="header-container">
            <!-- Logo section on the left side -->
            <div class="logo">
                <!-- Company logo image - replace logo.png with your actual logo file -->
                <img src="{{ url_for('static', filename='images/agrilogo.png') }}" alt="Store Logo" class="logo-img">
            </div>
            <!-- Navigation menu on the right side -->
            <nav class="nav-menu">
                <!-- Unordered list containing navigation links -->
                <ul class="nav-list">
                    <!-- Each list item contains a navigation link -->
                    <li><a href="{{ url_for('home.index') }}" class="nav-link">HOME</a></li>
                    <li><a href="{{ url_for('shop.shop_home') }}" class="nav-link">SHOP</a></li>
                    <li><a href="{{ url_for('incubatee_showroom.incubatee_showroom') }}" class="nav-link">INCUBATES</a></li>
                    <li><a href="{{ url_for('about.about_page')}}" class="nav-link">ABOUT</a></li>
                    <li><a href="{{ url_for('contact.contact_page')}}" class="nav-link">CONTACTS</a></li>
                    <li><a href="#" id="openCartBtn" class="nav-link cart-btn">üõí<span id="cartCountBadge" class="cart-count-badge">0</span></a></li>
                    <!-- Dynamic Login/Logout Button -->
                    {% if user_logged_in or admin_logged_in %}
                        <li>
                            <a href="{{ url_for('login.logout') }}" class="nav-link logout-btn">
                                LOGOUT
                            </a>
                        </li>
                    {% else %}
                        <li><a href="{{ url_for('login.login') }}" class="nav-link login-btn">LOGIN</a></li>
                    {% endif %}
                    <li><a href="javascript:void(0)" onclick="openUserDashboard()" class="nav-link dashboard-btn"><i class="fas fa-user"></i> DASHBOARD</a></li>
                </ul>
            </nav>
        </div>
    </header>

   <!-- Simplified Header Section -->
<section class="shop-header"></section>


    <!-- Filters Section -->
    <section class="filters-section">
        <div class="filters-container">
            <!-- üß≠ Category Filter -->
            <div class="category-filter">
            <label for="categorySelect">Filter by Category:</label>
            <select id="categorySelect" class="category-select">
                <option value="all" selected>All Categories</option>
            </select>
            </div>
            <div class="filter-group">
            <label class="filter-label" for="priceSelect">Price Range:</label>
            <select id="priceSelect" class="filter-select">
                <option value="all" selected>All Prices</option>
            </select>
            </div>
            <div class="filter-group">
            <label class="filter-label" for="sortSelect">Sort:</label>
            <select class="filter-select" id="sortSelect">
                <option value="newest">Newest First</option>
                <option value="price-low">Price: Low to High</option>
                <option value="price-high">Price: High to Low</option>
                <option value="popularity">Most Popular</option>
                <option value="rating">Highest Rated</option>
            </select>
            </div>

            <input type="text" class="search-box" id="searchInput" placeholder="Search products...">
        </div>
    </section>

    <!-- Products Section -->
    <section class="products-section">
    <div class="products-container">
        <div class="products-grid" id="productGrid"></div>
    </div>
    </section>

    <!-- üõí CART MODAL CONTAINER -->
    <div id="cartModal" class="cart-modal">
    <div class="cart-modal-content">
        <div id="cartContent"></div> <!-- cart.html will load here -->
    </div>
    </div>
    <div id="dashboardModal" class="dashboard-modal">
        <!-- Dashboard content will be loaded here dynamically -->
    </div>
    <!-- Back to Home Button -->
    <a href="{{ url_for('home.index') }}" class="back-to-home">‚Üê Back to Home</a>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 ATBI - Agri-Aqua Business Incubator. All rights reserved.</p>
        </div>
    </footer>
    <!-- JavaScript for product actions -->
    <script>
    // üõí Cart Functions
    async function updateCartCountFromBackend() {
        try {
            const res = await fetch('/cart/count');
            const data = await res.json();
            if (data.success) {
                const count = data.count || 0;
                const badge = document.getElementById('cartCountBadge');
                if (badge) {
                    badge.textContent = count;
                    badge.style.display = count > 0 ? 'inline-block' : 'none';
                    
                    // Add pulse animation when count changes
                    badge.classList.add('pulse');
                    setTimeout(() => badge.classList.remove('pulse'), 500);
                }
            }
        } catch (err) {
            console.error('Error fetching cart count:', err);
        }
    }

    // Optional: auto-update every 10-15 seconds
    function startCartCountInterval() {
        setInterval(updateCartCountFromBackend, 15000);
    }

    async function checkLoginStatus() {
        try {
            const res = await fetch("/login/status");
            if (!res.ok) return false;
            const data = await res.json();
            if (data.success) {
                // Optionally cache the user_id locally for quicker access
                sessionStorage.setItem("user_id", data.user_id || "");
                sessionStorage.setItem("username", data.username || "");
                return true;
            }
            return false;
        } catch (err) {
            console.error("Error checking login:", err);
            return false;
        }
    }

    // Require login before restricted actions
    async function requireLogin(action) {
        const isLoggedIn = await checkLoginStatus();
        if (!isLoggedIn) {
            alert(`Please log in to ${action}.`);
            window.location.href = '/login';
            return false;
        }
        return true;
    }

    // üõí Add to Cart (uses backend)
    async function addToCart(productId) {
        if (!(await requireLogin('add items to cart'))) return;

        const quantity = 1;

        try {
            const res = await fetch('/cart/add', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ product_id: productId, quantity })
            });

            const data = await res.json();
            if (data.success) {
                showNotification('Added to cart!', 'success');
                updateCartCountFromBackend(); // Update cart count after adding
            } else {
                showNotification(data.message || 'Failed to add to cart', 'error');
            }
        } catch (err) {
            console.error(err);
            showNotification('Server error. Try again later.', 'error');
        }
    }
        // Update reservation function to handle stock validation
        async function reserveProduct(productId) {
            if (!(await requireLogin('reserve products'))) return;

            // Check stock availability before proceeding
            try {
                const stockRes = await fetch(`/shop/product/${productId}/stock`);
                const stockData = await stockRes.json();
                
                if (!stockData.success) {
                    showNotification('Error checking product availability', 'error');
                    return;
                }
                
                if (stockData.product.current_stock <= 0) {
                    showNotification('This product is out of stock', 'error');
                    updateProductStockDisplay(); // Refresh display
                    return;
                }
                
                if (stockData.product.current_stock <= 5) {
                    showNotification('‚ö†Ô∏è Low stock! Only ' + stockData.product.current_stock + ' items left', 'info');
                }

            } catch (err) {
                console.error('Error checking stock:', err);
            }

            const quantity = 1;
            const userId = sessionStorage.getItem('user_id');

            try {
                const res = await fetch('/reservations/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ product_id: productId, quantity, user_id: userId })
                });

                const contentType = res.headers.get("content-type") || "";
                if (!contentType.includes("application/json")) {
                    showNotification('Session expired. Please log in again.', 'error');
                    window.location.href = '/login';
                    return;
                }

                const data = await res.json();
                if (data.success) {
                    showNotification(`Product reserved! Status: ${data.status}`, 'success');
                    updateReserveButton(productId, data.status);
                    
                    // Refresh stock display after successful reservation
                    setTimeout(() => {
                        refreshProductStocks();
                    }, 1000);
                } else {
                    showNotification(data.message || 'Reservation failed', 'error');
                }
            } catch (err) {
                console.error('‚ùå Reservation error:', err);
                showNotification('Server error. Try again later.', 'error');
            }
        }
    //  Update reserve button based on backend status
    function updateReserveButton(productId, status) {
        const button = document.querySelector(`[data-id="${productId}"] .reserve-btn`);
        if (!button) return;

        const colors = {
            pending: 'linear-gradient(135deg, #facc15 0%, #eab308 100%)',
            approved: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)',
            completed: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
            rejected: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)'
        };

        button.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        button.style.background = colors[status] || colors.pending;
        button.disabled = status !== 'pending';
    }
    // üîÑ Load user reservations (on page load)
    async function loadUserReservations() {
        const userId = sessionStorage.getItem('user_id');
        if (!userId) return;

        try {
            const res = await fetch(`/reservations/user/${userId}`);
            const data = await res.json();
            if (data.success && Array.isArray(data.reservations)) {
                data.reservations.forEach(r => updateReserveButton(r.product_id, r.status));
            }
        } catch (err) {
            console.error('Error loading reservations:', err);
        }
    }
    // üîî Notification pop-up
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            z-index: 10000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        `;

        const colors = {
            success: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)',
            error: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
            info: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
            default: 'linear-gradient(135deg, #6b7280 0%, #4b5563 100%)'
        };
        notification.style.background = colors[type] || colors.default;

        document.body.appendChild(notification);
        setTimeout(() => (notification.style.transform = 'translateX(0)'), 100);
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    // ‚ù§Ô∏è Enhanced Wishlist Functionality with Undo
    let lastWishlistAction = null;

    function addToWishlist(productId) {
        if (!requireLogin('add items to wishlist')) return;

        const card = document.querySelector(`[data-id="${productId}"]`);
        const productName = card.querySelector('.product-title').textContent;
        const productPrice = parseFloat(card.querySelector('.product-price').textContent.replace('‚Ç±', ''));
        const button = card.querySelector('.wishlist-btn');

        let wishlist = JSON.parse(localStorage.getItem('wishlist') || '[]');
        const existingIndex = wishlist.findIndex(item => item.id === productId);

        if (existingIndex === -1) {
            // Add to wishlist
            const wishlistItem = { 
                id: productId, 
                name: productName, 
                price: productPrice, 
                addedAt: new Date().toISOString() 
            };
            wishlist.push(wishlistItem);
            localStorage.setItem('wishlist', JSON.stringify(wishlist));
            
            // Animate addition
            animateWishlistAdd(button);
            updateWishlistButton(productId, true);
            
            // Store last action for undo
            lastWishlistAction = {
                type: 'add',
                productId: productId,
                productName: productName,
                timestamp: Date.now()
            };
            
            // Show undo notification
            showUndoNotification(`‚ù§Ô∏è "${productName}" added to wishlist!`);
            
        } else {
            // Remove from wishlist
            const removedItem = wishlist[existingIndex];
            wishlist.splice(existingIndex, 1);
            localStorage.setItem('wishlist', JSON.stringify(wishlist));
            
            // Animate removal
            animateWishlistRemove(button);
            updateWishlistButton(productId, false);
            
            // Store last action for undo
            lastWishlistAction = {
                type: 'remove',
                productId: productId,
                productName: productName,
                timestamp: Date.now()
            };
            
            // Show undo notification
            showUndoNotification(`üíî "${productName}" removed from wishlist!`);
        }
    }

    // Undo last wishlist action
    function undoLastWishlistAction() {
        if (!lastWishlistAction) return;
        
        const { type, productId, productName } = lastWishlistAction;
        const card = document.querySelector(`[data-id="${productId}"]`);
        const button = card?.querySelector('.wishlist-btn');
        
        let wishlist = JSON.parse(localStorage.getItem('wishlist') || '[]');
        
        if (type === 'add') {
            // Undo add = remove
            const index = wishlist.findIndex(item => item.id === productId);
            if (index !== -1) {
                wishlist.splice(index, 1);
                localStorage.setItem('wishlist', JSON.stringify(wishlist));
                if (button) {
                    animateWishlistRemove(button);
                    updateWishlistButton(productId, false);
                }
                showNotification(`‚ùå Undo: "${productName}" removed from wishlist`, 'info');
            }
        } else if (type === 'remove') {
            // Undo remove = add back
            const productPrice = parseFloat(card?.querySelector('.product-price')?.textContent.replace('‚Ç±', '') || 0);
            wishlist.push({ 
                id: productId, 
                name: productName, 
                price: productPrice, 
                addedAt: new Date().toISOString() 
            });
            localStorage.setItem('wishlist', JSON.stringify(wishlist));
            if (button) {
                animateWishlistAdd(button);
                updateWishlistButton(productId, true);
            }
            showNotification(`‚ù§Ô∏è Undo: "${productName}" added back to wishlist`, 'success');
        }
        
        lastWishlistAction = null;
    }

    // Animation functions
    function animateWishlistAdd(button) {
        button.classList.remove('removing', 'favorited');
        button.classList.add('adding');
        
        // Add ripple effect
        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        button.appendChild(ripple);
        
        setTimeout(() => {
            button.classList.remove('adding');
            button.classList.add('favorited', 'pulse');
            setTimeout(() => {
                button.classList.remove('pulse');
                ripple.remove();
            }, 600);
        }, 600);
    }

    function animateWishlistRemove(button) {
        button.classList.remove('adding', 'favorited', 'pulse');
        button.classList.add('removing');
        
        setTimeout(() => {
            button.classList.remove('removing');
        }, 600);
    }

    // Enhanced undo notification
    function showUndoNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification notification-info undo-notification';
        notification.innerHTML = `
            <span>${message}</span>
            <button class="undo-btn" onclick="undoLastWishlistAction()">Undo</button>
        `;
        
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 16px;
            color: white;
            font-weight: 600;
            z-index: 10000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            max-width: 400px;
            box-shadow: 0 8px 30px rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        `;

        document.body.appendChild(notification);
        
        // Slide in
        setTimeout(() => (notification.style.transform = 'translateX(0)'), 100);
        
        // Auto remove after 5 seconds
        const autoRemove = setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => notification.remove(), 300);
        }, 5000);
        
        // Clear auto-remove if user hovers
        notification.addEventListener('mouseenter', () => clearTimeout(autoRemove));
        notification.addEventListener('mouseleave', () => {
            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        });
    }

    // ‚ù§Ô∏è Update wishlist button state
    function updateWishlistButton(productId, isInWishlist) {
        const button = document.querySelector(`[data-id="${productId}"] .wishlist-btn`);
        if (button) {
            if (isInWishlist) {
                button.classList.add('favorited');
            } else {
                button.classList.remove('favorited');
            }
        }
    }
    // üõí Update cart totals (for cart modal)
    async function updateCartTotals() {
        try {
            const res = await fetch('/cart/totals');
            const data = await res.json();
            if (data.success) {
                // Update subtotal, tax, shipping, total elements
                const subtotalEl = document.getElementById('cartSubtotal');
                const taxEl = document.getElementById('cartTax');
                const shippingEl = document.getElementById('cartShipping');
                const totalEl = document.getElementById('cartTotal');
                
                if (subtotalEl) subtotalEl.textContent = `‚Ç±${data.subtotal?.toFixed(2) || '0.00'}`;
                if (taxEl) taxEl.textContent = `‚Ç±${data.tax?.toFixed(2) || '0.00'}`;
                if (shippingEl) shippingEl.textContent = `‚Ç±${data.shipping?.toFixed(2) || '0.00'}`;
                if (totalEl) totalEl.textContent = `‚Ç±${data.total?.toFixed(2) || '0.00'}`;
            }
        } catch (err) {
            console.error('Error updating cart totals:', err);
        }
    }

    // üõí Update cart item quantity
    async function updateCartItem(productId, quantity) {
        try {
            const res = await fetch('/cart/update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ product_id: productId, quantity })
            });

            const data = await res.json();
            if (data.success) {
                await updateCartCountFromBackend();
                await updateCartTotals();
                showNotification('Cart updated!', 'success');
            } else {
                showNotification(data.message || 'Failed to update cart', 'error');
            }
        } catch (err) {
            console.error('Error updating cart item:', err);
            showNotification('Server error. Try again later.', 'error');
        }
    }

    // üõí Remove item from cart
    async function removeCartItem(productId) {
        try {
            const res = await fetch('/cart/remove', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ product_id: productId })
            });

            const data = await res.json();
            if (data.success) {
                await updateCartCountFromBackend();
                await updateCartTotals();
                showNotification('Item removed from cart!', 'success');
                
                // Remove the item from DOM if cart modal is open
                const cartItem = document.querySelector(`[data-cart-item="${productId}"]`);
                if (cartItem) {
                    cartItem.remove();
                }
                
                // If cart is empty, show empty message
                const cartItemsContainer = document.querySelector('.cart-items');
                if (cartItemsContainer && cartItemsContainer.children.length === 0) {
                    cartItemsContainer.innerHTML = '<p class="empty-cart">Your cart is empty</p>';
                }
            } else {
                showNotification(data.message || 'Failed to remove item', 'error');
            }
        } catch (err) {
            console.error('Error removing cart item:', err);
            showNotification('Server error. Try again later.', 'error');
        }
    }
    // üöÄ On page load
    document.addEventListener('DOMContentLoaded', async () => {
        await updateCartCountFromBackend();
        await loadUserReservations();
        startCartCountInterval();

        // Initialize wishlist buttons
        const wishlist = JSON.parse(localStorage.getItem('wishlist') || '[]');
        wishlist.forEach(w => updateWishlistButton(w.id, true));
    });
    </script>
    <script src="{{ url_for('static', filename='js/cart.js') }}"></script>
    <script src="{{ url_for('static', filename='js/dashboard.js') }}"></script>
    <script>
    document.addEventListener("DOMContentLoaded", async () => {
        const searchBox = document.querySelector(".search-box");
        const categorySelect = document.getElementById("categorySelect");
        const priceSelect = document.getElementById("priceSelect");
        const sortSelect = document.getElementById("sortSelect");
        const productGrid = document.getElementById("productGrid");

        let products = [];

        try {
            // Fetch products from backend
            const response = await fetch("/shop/get-products");
            const data = await response.json();
            if (!data.success) throw new Error("Failed to fetch products");

            products = data.products;

            /* Populate Category Dropdown */
            const categories = [...new Set(products.map(p => p.category).filter(Boolean))];
            categorySelect.innerHTML = `<option value="all" selected>All Categories</option>`;
            categories.forEach(cat => {
                const option = document.createElement("option");
                option.value = cat;
                option.textContent = cat;
                categorySelect.appendChild(option);
            });

            /* Generate Dynamic Price Ranges */
            const prices = products.map(p => parseFloat(p.price_per_stocks)).filter(p => !isNaN(p));
            const minPrice = Math.floor(Math.min(...prices));
            const maxPrice = Math.ceil(Math.max(...prices));
            const range = maxPrice - minPrice;

            let numRanges = 3;
            if (range > 1000 && range <= 3000) numRanges = 4;
            else if (range > 3000) numRanges = 5;

            const step = Math.ceil(range / numRanges);
            const priceRanges = [];

            for (let i = 0; i < numRanges; i++) {
                const start = minPrice + i * step;
                const end = i === numRanges - 1 ? maxPrice : start + step;
                priceRanges.push({ start, end });
            }

            priceSelect.innerHTML = `<option value="all" selected>All Prices</option>`;
            priceRanges.forEach(r => {
                const option = document.createElement("option");
                option.value = `${r.start}-${r.end}`;
                option.textContent = `‚Ç±${r.start.toLocaleString()} - ‚Ç±${r.end.toLocaleString()}`;
                priceSelect.appendChild(option);
            });

            if (range > 5000) {
                const lastOption = document.createElement("option");
                lastOption.value = `${maxPrice}+`;
                lastOption.textContent = `‚Ç±${maxPrice.toLocaleString()}+`;
                priceSelect.appendChild(lastOption);
            }

            /*Initial render */
            renderProducts(products);

            /* Event listeners */
            categorySelect.addEventListener("change", () => applyFiltersAndSorting(products));
            priceSelect.addEventListener("change", () => applyFiltersAndSorting(products));
            sortSelect.addEventListener("change", () => applyFiltersAndSorting(products));

            /* Debounced Search with fuzzy matching */
            let searchTimeout;
            searchBox.addEventListener("input", () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => performSearch(searchBox.value.trim().toLowerCase()), 300);
            });

        } catch (err) {
            console.error("Error loading products:", err);
            productGrid.innerHTML = `<p style="color:red;">Error loading products.</p>`;
        }

        /* Search Function with fuzzy support */
        function performSearch(query) {
            if (!query) {
                applyFiltersAndSorting(products);
                return;
            }

            const filtered = products.filter(p => {
                const fields = [p.name, p.products, p.category, p.details]
                    .filter(Boolean)
                    .map(str => str.toLowerCase());

                return fields.some(field =>
                    field.includes(query) || getSimilarity(field, query) >= 0.7
                );
            });

            applyFiltersAndSorting(filtered);
        }

        /* Fuzzy match helpers */
        function getSimilarity(a, b) {
            const distance = levenshteinDistance(a, b);
            return 1 - distance / Math.max(a.length, b.length);
        }

        function levenshteinDistance(a, b) {
            const dp = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));
            for (let i = 0; i <= a.length; i++) dp[i][0] = i;
            for (let j = 0; j <= b.length; j++) dp[0][j] = j;
            for (let i = 1; i <= a.length; i++) {
                for (let j = 1; j <= b.length; j++) {
                    const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                    dp[i][j] = Math.min(
                        dp[i - 1][j] + 1,
                        dp[i][j - 1] + 1,
                        dp[i - 1][j - 1] + cost
                    );
                }
            }
            return dp[a.length][b.length];
        }

        /* Filter + Sort combo */
        function applyFiltersAndSorting(list) {
            const selectedCategory = categorySelect.value;
            const selectedPrice = priceSelect.value;
            const selectedSort = sortSelect.value;

            let filtered = [...list];

            // Category filter
            if (selectedCategory !== "all") {
                filtered = filtered.filter(p => p.category === selectedCategory);
            }

            // Price filter
            if (selectedPrice !== "all") {
                if (selectedPrice.includes("+")) {
                    const min = parseFloat(selectedPrice.replace("+", ""));
                    filtered = filtered.filter(p => p.price_per_stocks >= min);
                } else {
                    const [min, max] = selectedPrice.split("-").map(Number);
                    filtered = filtered.filter(p => p.price_per_stocks >= min && p.price_per_stocks <= max);
                }
            }

            // Sorting
            switch (selectedSort) {
                case "newest":
                    filtered.sort((a, b) => new Date(b.added_on) - new Date(a.added_on));
                    break;
                case "price-low":
                    filtered.sort((a, b) => a.price_per_stocks - b.price_per_stocks);
                    break;
                case "price-high":
                    filtered.sort((a, b) => b.price_per_stocks - a.price_per_stocks);
                    break;
            }

            smoothTransition(() => renderProducts(filtered));
        }

        /*Smooth fade transition */
        function smoothTransition(callback) {
            productGrid.style.opacity = "0";
            setTimeout(() => {
                callback();
                productGrid.style.opacity = "1";
            }, 200);
        }

        // üì¶ Stock Availability Functions
        function getStockStatus(stockCount) {
            if (stockCount === 0) return { text: 'Out of Stock', class: 'out-of-stock' };
            if (stockCount <= 5) return { text: 'Low Stock', class: 'low-stock' };
            if (stockCount <= 20) return { text: 'In Stock', class: 'in-stock' };
            return { text: 'High Stock', class: 'high-stock' };
        }

        function updateProductStockDisplay() {
            // This would be called after successful reservations to update stock display
            const productCards = document.querySelectorAll('.product-card');
            productCards.forEach(card => {
                const productId = card.dataset.id;
                // Fetch updated stock info for each product
                fetch(`/shop/product/${productId}/stock`)
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            const stockInfo = data.product;
                            const stockElement = card.querySelector('.product-stock');
                            if (stockElement) {
                                const status = getStockStatus(stockInfo.current_stock);
                                stockElement.textContent = `${status.text} (${stockInfo.current_stock} available)`;
                                stockElement.className = `product-stock ${status.class}`;
                            }
                        }
                    })
                    .catch(err => console.error('Error updating stock display:', err));
            });
        }
        // Update the renderProducts function to use stock_amount
        function renderProducts(products) {
            if (!products.length) {
                productGrid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üîç</div>
                        <h3>No products found</h3>
                        <p>Try adjusting your filters or search terms</p>
                    </div>`;
                return;
            }

            productGrid.innerHTML = products.map(p => {
                const imgSrc = p.image_path 
                    ? `/${p.image_path}`
                    : "{{ url_for('static', filename='images/no-image.png') }}";
                
                const stockStatus = getStockStatus(p.stock_amount || 0);
                const isOutOfStock = (p.stock_amount || 0) === 0;
                const incubateeName = p.incubatee?.company_name || '';
                
                // Category-based styling
                const isAgriAqua = p.category === 'Agri-Aqua Business';
                const categoryIcon = isAgriAqua ? 'üå±' : 'üçΩÔ∏è';
                const categoryColor = isAgriAqua ? '#10b981' : '#f59e0b';
                const categoryClass = isAgriAqua ? 'agri-aqua' : 'food-processing';

                return `
                    <div class="product-card ${categoryClass} ${isOutOfStock ? 'out-of-stock' : ''}" data-id="${p.product_id}">
                        <!-- Header with Category Only -->
                        <div class="product-header">
                            <div class="category-badge" style="--category-color: ${categoryColor}">
                                ${categoryIcon} ${p.category || 'General'}
                            </div>
                        </div>

                        <!-- Product Image -->
                        <div class="product-image-section">
                            <img src="${imgSrc}" alt="${p.name}" class="product-image" loading="lazy">
                            <div class="image-overlay">
                                ${stockStatus.text !== 'In Stock' ? 
                                    `<div class="stock-indicator ${stockStatus.class}">${stockStatus.text}</div>` : ''}
                                <button class="wishlist-btn" onclick="addToWishlist(${p.product_id})">
                                    <span class="heart-icon">‚ù§Ô∏è</span>
                                </button>
                            </div>
                        </div>

                        <!-- Product Info -->
                        <div class="product-info">
                            <h3 class="product-title">${p.name}</h3>
                            <p class="product-description">${p.details}</p>

                            <!-- Pricing & Stock -->
                            <div class="product-meta">
                                <div class="price-section">
                                    <span class="price">‚Ç±${parseFloat(p.price_per_stocks).toLocaleString(undefined, { minimumFractionDigits: 2 })}</span>
                                    <span class="price-unit">${p.pricing_unit}</span>
                                </div>
                                <div class="stock-section ${stockStatus.class}">
                                    <span class="stock-dot"></span>
                                    ${p.stock_amount} available
                                </div>
                            </div>

                            <!-- Additional Info -->
                            <div class="product-details">
                                ${p.expiration_date && p.expiration_date !== "No Expiry" ? 
                                    `<div class="detail-item">
                                        <span class="icon">üìÖ</span>
                                        Expires: ${p.expiration_date}
                                    </div>` : ''}
                                ${p.warranty && p.warranty !== "None" ? 
                                    `<div class="detail-item">
                                        <span class="icon">üõ°Ô∏è</span>
                                        ${p.warranty}
                                    </div>` : ''}
                            </div>

                            <!-- Actions -->
                            <div class="action-buttons">
                                <button class="btn-primary ${isOutOfStock ? 'disabled' : ''}" 
                                        onclick="addToCart(${p.product_id})" 
                                        ${isOutOfStock ? 'disabled' : ''}>
                                    <span class="btn-icon">üõí</span>
                                    ${isOutOfStock ? 'Out of Stock' : 'Add to Cart'}
                                </button>
                                <button class="btn-secondary ${isOutOfStock ? 'disabled' : ''}" 
                                        onclick="reserveProduct(${p.product_id})" 
                                        ${isOutOfStock ? 'disabled' : ''}>
                                    <span class="btn-icon">üìã</span>
                                    Reserve
                                </button>
                            </div>
                        </div>
                    </div>`;
            }).join("");
        }

        // Call this after successful reservations to update stock display
        async function refreshProductStocks() {
            try {
                const res = await fetch('/shop/product-availability');
                const data = await res.json();
                if (data.success) {
                    updateProductStockDisplay();
                }
            } catch (err) {
                console.error('Error refreshing product stocks:', err);
            }
        }
    });
    </script>
</body>
</html>
